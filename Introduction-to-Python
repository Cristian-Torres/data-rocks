## Multiplication, division, modulo, and exponentiation
print(3 * 5)
print(10 / 2)
print(18 % 7) # this operator returns the remainder of the division of the number to the left by the number on its right. For example 18 % 7 equals 4
print(4 ** 2)

## Variables and Types
# Remember, = in Python means assignment, it doesn't test equality.
# float: is Python's way of representing a real number. A number can have both an integer part and a fractional part.
x = 1.79

# int: short for integer, representing integer numbers.
y = 5

# strings (str): is Python's way to represent text. You can use both double and single quotes to build a string,
x = "body mass index"
y = 'this works too'
type(y)
str

# booleans (bool): is a type that can either be True or False.
z = True
type(z)
bool

print(type(z))
bool

# In Python, the plus operator behaved differently for different data types. General principle: how the code behaves depends on the types you're working with.
2 + 3
5

'ab' + 'cd'
'abcd'

## Converting variables: In Python, we use str(), to convert a value into a string. str(savings), for example, will convert Python values into any type.
## Similar functions such as int(), float(), and bool() will help you convert Python values into any type.
# Definition of savings and result
savings = 100
result = 100 * 1.10 ** 7

# Fix the printout
print("I started with $" + str(savings) + " and now have $" + str(result) + ". Awesome!")

# Definition of pi_string
pi_string = "3.1415926"

# Convert pi_string into float: pi_float
pi_float = float(pi_string)

## Python Lists
# A list is a way to give a single name to a collection of values. These values, or elements, can have any type. They can be floats, integer, string, booleans, even lists.
fam = [1.73, 1.68, 1.71, 1.89]
fam

fam = ["liz", 1.73, "emma", 1.68, "mom", 1.71, "dad", 1.89]
fam

fam2 = [["liz", 1.73],
        ["emma", 1.68],
        ["mom", 1.71],
        ["dad", 1.89]]
        
# area variables (in square meters)
hall = 11.25
kit = 18.0
liv = 20.0
bed = 10.75
bath = 9.50

# Adapt list areas
areas = ["halway", hall, "kitchen", kit, "living room", liv, "bedroom", bed, "bathroom", bath]

# Print areas
areas

## Subsetting lists: Liz would be index 0, the second element (1.73) would be index 1, and so on.
fam = ["liz", 1.73, "emma", 1.68, "mom", 1.71, "dad", 1.89]
fam

fam[3]
1.68
fam[6]
dad

## Negative indexes: you can also count backwards, using negative indexes.
fam[-1]
1.89

## List slicing: allows you to select multiple elements from a list, thus creating a new list. You cand do this by specifying a range, using a colon. Remember: [start(inclusive):end(exclusive)] 
fam = ["liz", 1.73, "emma", 1.68, "mom", 1.71, "dad", 1.89]
fam[3:5]
[1.68, 'mom']

fam[1:4]
[1.73, "emma", 1.68]

fam[:4]
["liz", 1.73, "emma", 1.68]

fam[5:]
[1.71, "dad", 1.89]

# Create the areas list
areas = ["hallway", 11.25, "kitchen", 18.0, "living room", 20.0, "bedroom", 10.75, "bathroom", 9.50]

# Sum of kitchen and bedroom area: eat_sleep_area
eat_sleep_area = areas[3] + areas[7]

# Print the variable eat_sleep_area
print(eat_sleep_area)

# Create the areas list
areas = ["hallway", 11.25, "kitchen", 18.0, "living room", 20.0, "bedroom", 10.75, "bathroom", 9.50]

# Use slicing to create downstairs
downstairs = areas[:6]

# Use slicing to create upstairs
upstairs = areas[6:]

# Print out downstairs and upstairs
print(downstairs)
print(upstairs)

## Subsetting lists of lists
## You saw before that a Python list can contain practically anything; even other lists! To subset lists of lists, you can use the same technique as before: square brackets. Try out the commands in the following code sample in the IPython Shell:

x = [["a", "b", "c"],
     ["d", "e", "f"],
     ["g", "h", "i"]]
x[2][0]
x[2][:2]
x[2] results in a list, that you can subset again by adding additional square brackets.

## What will house[-1][1] return? house, the list of lists that you created before, is already defined for you in the workspace. You can experiment with it in the IPython Shell.









